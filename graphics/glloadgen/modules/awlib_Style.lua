
local common = require "CommonStyle"
local struct = require "awlib_Struct"
local util = require "util"

local my_style = {}
my_style.header = {}
my_style.source = {}


----------------------------------------------------
-- Helper styling functions.
--
function replace(a, b)
	return a .. "_" .. b:lower();
end

function to_snake(name)
	local patterns = {
		-- unfortuately, requires manual input right now
		"([a-z])([0-9][A-Z]?[0-9a-z]*[a-z])$",
		"(.)([A-Z][a-z]+)",
		"([a-z])([0-9][A-Z])",
		"([a-z])([A-Z])"
	};

	for _,pattern in ipairs(patterns) do
		name = name:gsub(pattern, replace);
	end

	return name:lower();
end

local function Flatten(version)
	return version:gsub("%.","_");
end

local function GL33OrLater(version)
	_, _, v1, v2 = version:find( "(%d+)%.(%d+)" )
	local major = tonumber(v1)
	local minor = tonumber(v2)
	return major > 3 or (major == 3 and minor >= 3)
end

local function Clamp(version)
	if (GL33OrLater(version)) then
		return "3.2"
	end
	return version
end

local function GenIncludeGuardName(hFile, spec, options, suffix)
	local name = spec.GetIncludeGuardString():lower()
	if (options.version) then
		name = name .. "_" .. Flatten(options.version)
	end
	if (suffix) then
		name = name .. "_" .. suffix
	end

	local str = "gl_ext_" .. name .. "_h"

	if (#options.prefix > 0) then
		return options.prefix .. "_" .. str
	end
	
	return str
end

function BeginIncludeGuard(hFile, spec, options, suffix)
	local inclGuard = GenIncludeGuardName(hFile, spec, options, suffix)
	
	hFile:fmt("#ifndef %s\n", inclGuard)
	hFile:fmt("#define %s\n", inclGuard)
end

function EndIncludeGuard(hFile, spec, options, suffix)
	hFile:fmt("#endif//%s\n", GenIncludeGuardName(hFile, spec, options, suffix))
end

function BaseName(basename)
	local base, dir = util.ParsePath(basename)
	return base
end

local function StartNamespace(hFile, namespaceName)
	if (namespaceName) then
		hFile:fmt("namespace %s {\n", namespaceName)
	else
		hFile:fmt("namespace {\n")
	end
end

local function EndNamespace(hFile, namespaceName)
	if (namespaceName) then
		hFile:fmt("} //namespace %s\n", namespaceName)
	else
		hFile:fmt("} //namespace\n")
	end
end

local function StartPrefixNamespace(hFile, spec, options)
	if(#options.prefix > 0) then
		StartNamespace(hFile, options.prefix)
	end
end

local function EndPrefixNamespace(hFile, spec, options)
	if(#options.prefix > 0) then
		EndNamespace(hFile, options.prefix)
	end
end

local function VersionComment(hFile, version, spec, options)
	hFile:write("/* " .. options.spec .. " version " .. version .. " */\n")
end

local function ExtensionComment(hFile, extName, spec, options)
	hFile:write("/* " .. options.spec .. " extension " .. extName .. " */\n")
end

local function Preamble(hFile)
	hFile:write[[
/*
 * This file is automatically generated.
 */
]]
end

local function GetCodegenPtrType(options)
	local str = options.spec:upper() .. "_API"
	if (options.prefix ~= nil) then
		str = options.prefix:upper() .. str
	end
	return str
end

local function GenFuncPtrName(func, spec, options)
	return to_snake(func.name)
end

local function GenFuncName(func, spec, options)
	return to_snake(func.name)
end

local function GenFuncPtrTypedefName(func, spec, options)
	return GenFuncPtrName(func, spec, options) .. "_ptr"
end

local function GenEnumNamePrefix(enum, spec, options)
	return spec.EnumNamePrefix() .. enum.name
end

local function GenEnumName(enum, spec, options)
	--return common.GetCppEnumName(enum):lower()
	return GenEnumNamePrefix(enum, spec, options)
end

local function GenExtensionVarName(extName, spec, options)
	return "var_" .. extName:lower();
end

local function GenExtLoaderFuncName(extName, spec, options)
	return "load_" .. extName:lower();
end

local function GenQualifiedEnumName(enum, spec, options)
	-- return spec.FuncNamePrefix() .. "::" .. GenEnumName(enum, spec, options)
	return GenEnumName(enum, spec, options)
end

local function GenQualifiedFuncPtrName(func, spec, options)
	return spec.FuncNamePrefix() .. "::" .. GenFuncName(func, spec, options)
end

local function GenQualifiedFuncName(func, spec, options)
	return spec.FuncNamePrefix() .. "::" .. GenFuncName(func, spec, options)
end

------------------------------------------------------
-- Header styling functions
my_style.header.WriteFilePreamble = Preamble

function my_style.header.GetFilename(basename, options)
	return basename .. ".h"
end

function my_style.header.GetEnumFilename(basename, options)
	return basename .. "_enum.h"
end

function my_style.header.GetWrapperFilename(basename, options)
	return basename .. "_func.h"
end

my_style.header.WriteBlockBeginIncludeGuard = BeginIncludeGuard
my_style.header.WriteBlockEndIncludeGuard   = EndIncludeGuard

function my_style.header.WriteBlockBeginIncludeGuardEnum(hFile, spec, options)
	BeginIncludeGuard(hFile, spec, options, "enum")
end

function my_style.header.WriteBlockEndIncludeGuardEnum(hFile, spec, options)
	EndIncludeGuard(hFile, spec, options, "enum")
end

function my_style.header.WriteInit(hFile, spec, options)
	--hFile:rawwrite(spec.GetHeaderInit())
end

function my_style.header.WriteStdIncludes(hFile, basename, spec, options)
	hFile:write('#include "types.h"\n')
	hFile:fmt('#include "%s_enum.h"\n', BaseName(basename))
end

function my_style.header.WriteSpecTypedefs(hFile, specData, spec, options)
	--[[for k,v in pairs(specData) do
		print(k,v)
	end]]
end

function my_style.header.WriteBlockBeginDecl(hFile, spec, options)
	StartPrefixNamespace(hFile, spec, options)
	StartNamespace(hFile, spec.FuncNamePrefix())
end

function my_style.header.WriteBlockEndDecl(hFile, spec, options)
	EndNamespace(hFile, spec.FuncNamePrefix())
	EndPrefixNamespace(hFile, spec, options)
end


my_style.header.WriteExtensionComment = ExtensionComment;
my_style.header.WriteVersionComment   = VersionComment;

function my_style.header.WriteBlockBeginExtVarDecl(hFile, spec, options)
	StartNamespace(hFile, "ext")
	hFile:writeblock[[
struct load_result {
	explicit operator bool() const
	{
		return is_loaded;
	}
	
	int num_missing() const { return missing; }
	
	load_result() = default;
	load_result(bool is_loaded, int num_missing)
		: is_loaded{is_loaded}, missing{num_missing}
	{}

private:
	bool is_loaded   = false;
	int  missing = 0;
};
]]
	hFile:write("\n")
end

function my_style.header.WriteBlockEndExtVarDecl(hFile, spec, options)
	EndNamespace(hFile, "ext")
end

function my_style.header.WriteExtVariableDecl(hFile, extName,
	specData, spec, options)
	hFile:fmt("extern load_result %s;\n",
		GenExtensionVarName(extName, spec, options));
end

function my_style.header.WriteBlockBeginEnumDecl(hFile, spec, options)
	StartPrefixNamespace(hFile, spec, options)
	hFile:write("enum {\n")
	hFile:inc()
end

function my_style.header.WriteBlockEndEnumDecl(hFile, spec, options)
	hFile:dec()
	hFile:write("};\n")
	EndPrefixNamespace(hFile, spec, options)
end

function my_style.header.WriteEnumDecl(hFile, enum, enumTable, spec, options, enumSeen)
	if(enumSeen[enum.name]) then
		hFile:fmt("//%s taken from ext: %s\n", enum.name, enumSeen[enum.name])
	else
	
		local enumName = GenEnumName(enum, spec, options)
		local lenEnum = #enumName
		local numIndent = 33
		
		local numSpaces = numIndent - lenEnum
		if(numSpaces < 1) then
			numSpaces = 1
		end

		hFile:fmt("%s%s= %s,\n",
			enumName,
			string.rep(" ", numSpaces),
			common.ResolveEnumValue(enum, enumTable))
	end
end

function my_style.header.WriteBlockBeginFuncPtrDecl(hFile, spec, options)
end

function my_style.header.WriteBlockEndFuncPtrDecl(hFile, spec, options)
end

function my_style.header.WriteBlockBeginExtFuncPtrDecl(hFile, extName, spec, options)
	--Block containing all spec function declarations for a particular extension.
	--Useful for include-guards around extension function pointers.
end

function my_style.header.WriteBlockEndExtFuncPtrDecl(hFile, extName, spec, options)
	--Block containing all spec function declarations for a particular extension.
end

	local function WriteFuncPtrTypedefStmt(hFile, func, spec, options)
		hFile:fmt("using %s = %s (%s *)(%s);\n",
			GenFuncPtrTypedefName(func, spec, options),
			common.GetFuncReturnType(func),
			GetCodegenPtrType(options),
			common.GetFuncParamList(func))
	end

	local function GenFuncPtrDefDirect(func, spec, options)
		return string.format("%s (%s* %s)(%s)",
			common.GetFuncReturnType(func),
			GetCodegenPtrType(options),
			GenFuncPtrName(func, spec, options),
			common.GetFuncParamList(func, true))
	end

	local function GenFuncPtrDefTypedef(func, spec, options)
		return string.format("%s %s",
			GenFuncPtrTypedefName(func, spec, options),
			GenFuncPtrName(func, spec, options))
	end

	local function GenFuncPtrDefDecltype(func, spec, options)
		return string.format("decltype(%s) %s",
			GenFuncPtrName(func, spec, options),
			GenFuncPtrName(func, spec, options))
	end

function my_style.header.WriteFuncPtrDecl(hFile, func, spec, options)
	-- TODO: remove AW_GRAPHICS_EXP, make all functions private
	hFile:write("AW_GRAPHICS_EXP extern ", GenFuncPtrDefDirect(func, spec, options), ";\n")
end

function my_style.header.WriteBlockBeginFuncDecl(hFile, spec, options)
end

function my_style.header.WriteBlockEndFuncDecl(hFile, spec, options)
end

function my_style.header.WriteBlockBeginExtFuncDecl(hFile, extName, spec, options)
	--Block containing all spec function declarations for a particular extension.
	--Useful for include-guards around extension function pointers.
end

function my_style.header.WriteBlockEndExtFuncDecl(hFile, extName, spec, options)
	--Block containing all spec function declarations for a particular extension.
end

function my_style.header.WriteFuncDecl(hFile, func, spec, options)
	hFile:fmt("inline %s %s(%s)\n{\n",
			common.GetFuncReturnType(func),
			GenFuncName(func, spec, options),
			common.GetFuncParamList(func, true))

	hFile:inc()

	if(common.DoesFuncReturnSomething(func)) then
		hFile:fmt('%s(%s);\n',
			GenQualifiedFuncPtrName(func, spec, options),
			common.GetFuncParamCallList(func))
	else
		hFile:fmt('return %s(%s);\n',
			GenQualifiedFuncPtrName(func, spec, options),
			common.GetFuncParamCallList(func))
	end

	hFile:dec()

	hFile:rawwrite("}\n")
end



function my_style.header.WriteBlockBeginSysDecl(hFile, spec, options)
	StartNamespace(hFile, "sys")
end

function my_style.header.WriteBlockEndSysDecl(hFile, spec, options)
	EndNamespace(hFile, "sys")
end

function my_style.header.WriteUtilityDecls(hFile, spec, options)
	--Write declarations for public utility stuff. Enums for return values, etc.
end

function my_style.header.WriteMainLoaderFuncDecl(hFile, spec, options)
	if (options.version) then
		local name = "load_functions_" .. Flatten(options.version)
		hFile:fmt("%s::load_result %s(%s);\n", "ext", name, spec.GetLoaderParams())
	end
end

function my_style.header.WriteVersioningFuncDecls(hFile, spec, options)
	hFile:writeblock([[
int get_minor_version();
int get_major_version();
bool is_version_geq(int major, int minor);
]])
end

--------------------------------------------------
-- Source code styling functions.
my_style.source.WriteFilePreamble = Preamble

function my_style.source.GetFilename(basename, options)
	return basename .. ".c++"
end

function my_style.source.WriteIncludes(hFile, basename, spec, options)
	local base = util.ParsePath(my_style.header.GetFilename(basename, options))
	hFile:fmt('#include "%s"\n\n', base)

	hFile:writeblock([[
#include "loader.h"
#include <vector>
#include <aw/types/string_view.h>
#include <aw/algorithm/binary_find.h>
]])
end

function my_style.source.WriteLoaderData(hFile, spec, options)
	--hFile:writeblock(spec.GetLoaderFunc())
end

function my_style.source.WriteBlockBeginDef(hFile, spec, options)
	if(#options.prefix > 0) then
		StartNamespace(hFile, options.prefix)
	end
	StartNamespace(hFile, spec.FuncNamePrefix())
end

function my_style.source.WriteBlockEndDef(hFile, spec, options)
	EndNamespace(hFile, spec.FuncNamePrefix())
	if(#options.prefix > 0) then
		EndNamespace(hFile, options.prefix)
	end
end

function my_style.source.WriteBlockBeginExtVarDef(hFile, spec, options)
	StartNamespace(hFile, "ext")
end

function my_style.source.WriteBlockEndExtVarDef(hFile, spec, options)
	EndNamespace(hFile, "ext")
end

function my_style.source.WriteExtVariableDef(hFile, extName,
	specData, spec, options)
	hFile:fmt("load_result %s;\n", GenExtensionVarName(extName, spec, options));
end

function my_style.source.WriteBlockBeginPtrDefs(hFile, spec, options)
end

function my_style.source.WriteBlockEndPtrDefs(hFile, spec, options)
end

function my_style.source.WriteBlockBeginExtFuncPtrDef(hFile, extName, spec, options)
end

function my_style.source.WriteBlockEndExtFuncPtrDef(hFile, extName, spec, options)
end

my_style.source.WriteVersionComment = VersionComment;

function my_style.source.WriteFuncPtrDef(hFile, func, spec, options)
	hFile:write(GenFuncPtrDefDecltype(func, spec, options), " = 0;\n")
end

function my_style.source.WriteBlockBeginExtLoader(hFile, extName, spec, options)
	hFile:fmt("static int %s()\n", GenExtLoaderFuncName(extName, spec, options))
	hFile:write("{\n")
	hFile:inc()
	hFile:write("int num_failed = 0;\n")
end

function my_style.source.WriteBlockEndExtLoader(hFile, extName, spec, options)
	hFile:write "return num_failed;\n"
	hFile:dec()
	hFile:write("}\n")
end

function my_style.source.WriteExtFuncLoader(hFile, func, spec, options)
	hFile:fmt('get_proc(%s, "%s%s");\n',
		GenFuncPtrName(func, spec, options),
		spec.FuncNamePrefix(), func.name)
end

function my_style.source.WriteBlockBeginCoreFuncPtrDef(hFile, version, spec, options)
end

function my_style.source.WriteBlockEndCoreFuncPtrDef(hFile, version, spec, options)
end

function my_style.source.WriteBlockBeginCoreLoaders(hFile, version, spec, options)
	StartNamespace(hFile)
end

function my_style.source.WriteBlockEndCoreLoaders(hFile, version, spec, options)
	EndNamespace(hFile)
end

my_style.source.FilterGL33OrLater = GL33OrLater

local function GenCoreLoaderFuncName(version, spec, options)
	return "load_gl_" .. Flatten(version) .. "_functions"
end

local function BlockBeginCoreLoaderPre(hFile, version, spec, options)
	hFile:fmt("int %s()\n", GenCoreLoaderFuncName(version, spec, options))
	hFile:write("{\n")
	hFile:inc()
	hFile:write("int num_failed = ")
end

local function BlockBeginCoreLoaderPost(hFile, version, spec, options)
	hFile:writeblock([[
auto core_load_func = [&] (auto& func, char const* spec) {
	get_proc(func, spec);
	if (!func) ++num_failed;
};
]])
end

local function BlockEndCoreLoader(hFile, version, spec, options)
	hFile:write "return num_failed;\n"
	hFile:dec()
	hFile:write("}\n")
end


function my_style.source.WriteBlockBeginCoreLoaderOld(hFile, spec, options)
	local version = Clamp(options.version)
	if (options.version) then
		BlockBeginCoreLoaderPre(hFile, version, spec, options);
		hFile:rawwrite("0;\n");
		BlockBeginCoreLoaderPost(hFile, version, spec, options)
	end
end

local prev_version = "3.2"
function my_style.source.WriteBlockBeginCoreLoader(hFile, version, spec, options)
	BlockBeginCoreLoaderPre(hFile, version, spec, options);
	local func = GenCoreLoaderFuncName(prev_version, spec, options)
	hFile:rawwrite(func .. '();\n')
	prev_version = version
	BlockBeginCoreLoaderPost(hFile, version, spec, options)
end

my_style.source.WriteBlockEndCoreLoaderOld = BlockEndCoreLoader
my_style.source.WriteBlockEndCoreLoader    = BlockEndCoreLoader

function my_style.source.WriteCoreFuncLoader(hFile, func, spec, options)
	local load_func = 'core_load_func(%s, "%s%s");\n';
	--Special hack for DSA_EXT functions in core functions.
	--They do not count against the loaded count.
	if (func.name:match("EXT$")) then
		hFile:write("//An EXT_direct_state_access-based function. Don't count it if it fails to load.\n")
		load_func = 'get_proc(%s, "%s%s");\n';
	end

	hFile:fmt(load_func,
		GenFuncPtrName(func, spec, options),
		spec.FuncNamePrefix(), func.name)
end

function my_style.source.WriteExtStringFuncDef(hFile, specData, spec, options, funcSeen)
	if(funcSeen[spec.GetExtStringFuncName()]) then
		return
	end
	
	--Check to see if its something we have to load.
	local function FindFuncName(funcName)
		for _, func in ipairs(specData.funcData.functions) do
			if(func.name == funcName) then
				return func
			end
		end
		
		return nil
	end
	
	local extStringFunc = FindFuncName(spec.GetExtStringFuncName())

	if(extStringFunc) then
		hFile:write("\n")
		WriteFuncPtrTypedefStmt(hFile, extStringFunc, spec, options)
		hFile:write("static ", GenFuncPtrDefTypedef(extStringFunc, spec, options), " = 0;\n")
		hFile:write("\n")
	end
end

function my_style.source.WriteBlockBeginSysDef(hFile, spec, options)
	StartNamespace(hFile, "sys")
end

function my_style.source.WriteBlockEndSysDef(hFile, spec, options)
	EndNamespace(hFile, "sys")
end

function my_style.source.WriteBlockBeginSysInternal(hFile, spec, options)
	StartNamespace(hFile)
end

function my_style.source.WriteBlockEndSysInternal(hFile, spec, options)
	EndNamespace(hFile)
end


function my_style.source.WriteUtilityDefs(hFile, specData, spec, options)
	--Write our mapping table definitions.
	hFile:writeblock[[
using load_extension_ptr = int(*)();
struct map_entry {
	string_view ext_name;
	ext::load_result* ext_variable;
	load_extension_ptr loaderFunc = nullptr;
};

bool operator<(map_entry const& a, map_entry const& b)
{
	return a.ext_name < b.ext_name;
}

bool operator==(map_entry const& a, map_entry const& b)
{
       return a.ext_name == b.ext_name;
}
]]
	hFile:write "\n"

	--Write the table initialization function.
	hFile:write "void initialize_mapping_table()\n"
	hFile:write "{\n"
	hFile:inc()
	hFile:write "std::vector<map_entry> table(%i);\n"
	hFile:write "int i = 0;\n"
	for _, extName in ipairs(options.extensions) do
		if(#specData.extdefs[extName].funcs > 0) then
			hFile:fmt('table[i++] = { "%s", ext::%s, %s };\n',
				spec.ExtNamePrefix() .. extName,
				GenExtensionVarName(extName, spec, options),
				GenExtLoaderFuncName(extName, spec, options))
		else
			hFile:fmt('table[i++] = { "%s", ext::%s };\n',
				spec.ExtNamePrefix() .. extName,
				GenExtensionVarName(extName, spec, options))
		end
	end
	hFile:write("std::sort(begin(table), end(table));\n")
	hFile:dec()
	hFile:write "}\n"
	hFile:write "\n"
	
	--Write the function to clear the extension variables.
	hFile:fmt("void clear_extension_vars()\n")
	hFile:write("{\n")
	hFile:inc()
	for _, extName in ipairs(options.extensions) do
		hFile:fmt('ext::%s = ext::load_result();\n',
			GenExtensionVarName(extName, spec, options))
	end
	hFile:dec()
	hFile:write("}\n")
	hFile:write "\n"
	
	--Write a function that loads an extension by name. It is called when
	--processing, so it should also set the extension variable based on the load.
	hFile:writeblock([[
void load_extension(std::vector<map_entry>& table, string_view extension)
{
	auto compare = [] (map_entry const& e, string_view a)
	{
		return a == e.ext_name;
	};
	auto entry = aw::binary_find(begin(table), end(table), extension, compare);
	
	if (entry != end(table)) {
		if(entry->loaderFunc)
			(*entry->ext_variable) = ext::load_result(true, entry->loaderFunc());
		else
			(*entry->ext_variable) = ext::load_result(true, 0);
	}
}
]])
	hFile:write "\n"
end
	
local function WriteAncillaryFuncs(hFile, specData, spec, options)
	local indexed = spec.GetIndexedExtStringFunc(options);
	if(indexed) then
		for _, func in ipairs(specData.funcData.functions) do
			if(indexed[1] == func.name) then
				indexed[1] = func
			end
			if(indexed[3] == func.name) then
				indexed[3] = func
			end
		end
		for _, enum in ipairs(specData.enumerators) do
			if(indexed[2] == enum.name) then
				indexed[2] = enum
			end
			if(indexed[4] == enum.name) then
				indexed[4] = enum
			end
		end
		
			hFile:writeblock([[
static void ProcExtsFromExtList(std::vector<map_entry> &table)
{
	GLint idx;
	GLint num = 0;
	]] .. GenQualifiedFuncName(indexed[1], spec, options)
	.. [[(]] .. GenQualifiedEnumName(indexed[2], spec, options)
	.. [[, &num);

	for(idx = 0; idx < num; ++idx) {
		const char* strExtensionName = (const char *)]] ..
		GenQualifiedFuncName(indexed[3], spec, options) ..
		[[(]] .. GenQualifiedEnumName(indexed[4], spec, options) .. [[, idx);
		LoadExtByName(table, strExtensionName);
	}
}
]])
	else
		hFile:writeblock(common.GetProcessExtsFromStringFunc(
			"LoadExtByName(table, %s)", ", std::vector<map_entry> &table"))
	end

	return indexed
end

	
local function WriteInMainFuncLoader(hFile, func, spec, options)
	hFile:fmt('get_proc(%s, "%s%s");\n',
		GenFuncPtrName(func, spec, options),
		spec.FuncNamePrefix(), func.name)
	hFile:fmt('if(!%s) return ext::load_result();\n',
		GenFuncPtrName(func, spec, options))
end

function my_style.source.WriteMainLoaderHelpers(hFile, specData, spec, options)
	local indexed = WriteAncillaryFuncs(hFile, specData, spec, options)
	hFile:write "\n"

	hFile:fmt("ext::load_result load_functions_ext(%s)\n", spec.GetLoaderParams())
	hFile:write("{\n")
	hFile:inc()
	hFile:writeblock[[
clear_extension_vars();
std::vector<map_entry> table = initialize_mapping_table();
]]
	hFile:write("\n")

	if(indexed) then
		WriteInMainFuncLoader(hFile, indexed[1], spec, options)
		WriteInMainFuncLoader(hFile, indexed[3], spec, options)
		hFile:write("\n")
		hFile:write("ProcExtsFromExtList(table);\n")
	else
		local extListName, needLoad = spec.GetExtStringFuncName()
		if(needLoad) then
			for _, func in ipairs(specData.funcData.functions) do
				if(extListName == func.name) then
					extListName = func
					break
				end
			end
			
			WriteInMainFuncLoader(hFile, extListName, spec, options)
			
			extListName = GenQualifiedFuncPtrName(extListName, spec, options);
		end

		local function EnumResolve(enumName)
			return GenQualifiedEnumName(specData.enumtable[enumName], spec, options)
		end
		
		hFile:write "\n"
		hFile:fmt("ProcExtsFromExtString((const char *)%s(%s), table);\n",
			extListName,
			spec.GetExtStringParamList(EnumResolve))
	end
	
	hFile:dec()
	hFile:write("}\n")
end

local function WriteMainLoaderFunc(hFile, version, specData, spec, options)
	local func_name   = "load_functions_" .. Flatten(version)
	local loader_func = GenCoreLoaderFuncName(version, spec, options)
	hFile:fmt("ext::load_result %s(%s)\n", func_name, spec.GetLoaderParams())
	hFile:write "{\n"
	hFile:inc()
	hFile:write("load_functions_ext();\n\n")
	hFile:fmt("int num_failed = %s();\n", loader_func)
	
	hFile:write("return ext::load_result(true, num_failed);\n")

	hFile:dec()
	hFile:write("}\n")
end

function my_style.source.WriteMainLoaderFuncOld(hFile, specData, spec, options)
	version = Clamp(options.version)
	WriteMainLoaderFunc(hFile, version, specData, spec, options)
end

my_style.source.WriteMainLoaderFunc = WriteMainLoaderFunc

function my_style.source.WriteVersioningFuncs(hFile, specData, spec, options)
	hFile:fmt("static int g_major_version = 0;\n")
	hFile:fmt("static int g_minor_version = 0;\n")
	hFile:write "\n"
	
	if (tonumber(options.version) >= 3.0) then
		hFile:writeblock([[
static void get_gl_version()
{
	get_integerv(GL_MAJOR_VERSION, &g_major_version);
	get_integerv(GL_MINOR_VERSION, &g_minor_version);
}
]])
	else
		hFile:writeblock(common.GetParseVersionFromString())
		hFile:write "\n"
		
		hFile:writeblock([[
static void get_gl_version()
{
	ParseVersionFromString(&g_major_version, &g_minor_version, (const char *)get_string(VERSION));
}
]])
	end
	
	hFile:write "\n"
	hFile:writeblock([[
int get_major_version()
{
	if(g_major_version == 0)
		get_gl_version();
	return g_major_version;
}
]])
	hFile:write "\n"

	hFile:writeblock([[
int get_minor_version()
{
	//Yes, check the major version to get the minor one.
	if(g_major_version == 0)
		get_gl_version();
	return g_minor_version;
}
]])
	hFile:write "\n"

	common.WriteCIsVersionGEQFunc(hFile,
		{
			returnType = "bool",
			funcName = "is_version_geq",
			True = "true",
			False = "false",
			majorVersion = "g_major_version",
			minorVersion = "g_minor_version",
			verLoader = "get_gl_version",
		})

end


--------------------------------------------------
-- Style retrieval machinery

local function Create()
	return common.DeepCopyTable(my_style), struct
end

return { Create = Create }
